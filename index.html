<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Erweitertes 3D-Web-Spiel</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #gameContainer { width: 100%; height: 100vh; }
        #joystick { position: absolute; bottom: 20px; left: 20px; width: 100px; height: 100px; background: rgba(255,255,255,0.5); border-radius: 50%; }
        #instructions { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div id="joystick"></div>
    <div id="instructions">
        Desktop: WASD zum Bewegen, SHIFT zum Rennen<br>
        Mobil: Joystick zum Bewegen, Doppeltipp zum Rennen
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
    <script>
        let scene, camera, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, isRunning = false;
        let velocity = new THREE.Vector3();
        let buildings = [];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            const light = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(light);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 1, 0);
            scene.add(directionalLight);

            // Boden
            const planeGeometry = new THREE.PlaneGeometry(1000, 1000);
            const planeMaterial = new THREE.MeshBasicMaterial({color: 0x555555, side: THREE.DoubleSide});
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = Math.PI / 2;
            plane.position.y = 0;
            scene.add(plane);

            // Zufällige Gebäude generieren
            for (let i = 0; i < 100; i++) {
                createRandomBuilding();
            }

            setupJoystick();
            setupKeyboardControls();
            animate();
        }

        function createRandomBuilding() {
            const width = Math.random() * 10 + 5;
            const height = Math.random() * 30 + 10;
            const depth = Math.random() * 10 + 5;
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({color: Math.random() * 0xffffff});
            const building = new THREE.Mesh(geometry, material);
            
            building.position.x = Math.random() * 1000 - 500;
            building.position.y = height / 2;
            building.position.z = Math.random() * 1000 - 500;
            
            scene.add(building);
            buildings.push(building);
        }

        function setupJoystick() {
            const joystick = nipplejs.create({
                zone: document.getElementById('joystick'),
                mode: 'static',
                position: {left: '60px', bottom: '60px'},
                color: 'blue'
            });

            joystick.on('move', function(evt, data) {
                const force = data.force < 1 ? data.force : 1;
                const angle = data.angle.radian;
                moveForward = Math.cos(angle) > 0.3;
                moveBackward = Math.cos(angle) < -0.3;
                moveLeft = Math.sin(angle) < -0.3;
                moveRight = Math.sin(angle) > 0.3;
                velocity.z = -Math.cos(angle) * force * (isRunning ? 0.2 : 0.1);
                velocity.x = Math.sin(angle) * force * (isRunning ? 0.2 : 0.1);
            });

            joystick.on('end', function() {
                moveForward = moveBackward = moveLeft = moveRight = false;
                velocity.set(0, 0, 0);
            });

            let lastTap = 0;
            document.addEventListener('touchend', function(event) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                if (tapLength < 500 && tapLength > 0) {
                    isRunning = !isRunning;
                }
                lastTap = currentTime;
            });
        }

        function setupKeyboardControls() {
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': isRunning = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isRunning = false; break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const speed = isRunning ? 0.2 : 0.1;
            if (moveForward) velocity.z -= speed;
            if (moveBackward) velocity.z += speed;
            if (moveLeft) velocity.x -= speed;
            if (moveRight) velocity.x += speed;

            velocity.multiplyScalar(0.9); // Reibung
            camera.position.add(velocity);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
